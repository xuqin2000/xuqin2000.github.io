<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL索引 第三篇</title>
      <link href="2021/03/27/MySQL%E7%B4%A2%E5%BC%95%20%E7%AC%AC%E4%B8%89%E7%AF%87/"/>
      <url>2021/03/27/MySQL%E7%B4%A2%E5%BC%95%20%E7%AC%AC%E4%B8%89%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="性能分析-explain"><a href="#性能分析-explain" class="headerlink" title="性能分析(explain)"></a>性能分析(explain)</h3><p>​        是什么：使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。</p><p>​        做什么：那么explain能够干嘛呢？它大概可以分析出以下几点：</p><ol><li><p>表的读取顺序</p></li><li><p>那些索引可以使用</p></li><li><p>数据读取操作的操作类型</p></li><li><p>哪些索引被实际使用</p></li><li><p>表之间的应用</p></li><li><p>每张表有多少行被优化器查询</p><p>如何做：很简单，我们只要在要执行的sql语句前面加上一个explain即可。<br>执行之后，可以看到如图：<br><img src="../../../Users/xuqin/Typora/d464fccea0517b49.png" alt="image.png"></p></li></ol><h4 id="各字段解释"><a href="#各字段解释" class="headerlink" title="各字段解释"></a>各字段解释</h4><ul><li><p>id：select查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序</p><ol><li><p>id相同，执行顺序由上至下</p></li><li><p>id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p></li><li><p>id有相同也有不同，同时存在。id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</p></li></ol></li><li><p>select_type：查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询</p></li><li><p>table：显示这一行的数据是关于哪张表的</p></li><li><p>type：显示查询使用了何种类型，从<strong>最好到最差</strong>依次是system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</p></li><li><p>possible_keys: 显示可能应用在这张表中的索引，一个或多个。<br>查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</p></li><li><p>key:  实际使用的索引。如果为NULL，则没有使用索引</p></li><li><p>key_len</p></li><li><p>ref</p></li><li><p>rows</p></li><li><p>Extra</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引 第二篇</title>
      <link href="2021/03/26/MySQL%E7%B4%A2%E5%BC%95%20%E7%AC%AC%E4%BA%8C%E7%AF%87/"/>
      <url>2021/03/26/MySQL%E7%B4%A2%E5%BC%95%20%E7%AC%AC%E4%BA%8C%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="MySQL索引结构"><a href="#MySQL索引结构" class="headerlink" title="MySQL索引结构"></a>MySQL索引结构</h3><p>在数据库中，索引是有很多种类的。有B树索引、B+树索引、hash索引等等。<br>不同的索引是为了在不同的场合下应用。我们最常听到的索引应该就是B+树索引。因为MySQL中innodb的普通索引就是使用的B+Tree索引。 </p><ul><li><p> BTree索引<br>Myisam普通索引</p></li><li><p> B+Tree索引<br>innodb的普通索引</p></li><li><p>Hash索引<br>Hash索引只有Memory, NDB两种引擎支持，Memory引擎默认支持Hash索引，如果多个hash值相同，出现哈希碰撞，那么索引以链表方式存储。<br>NoSql采用此中索引结构。</p></li><li><p>B+Tree与B-Tree 的区别：结论在内存有限的情况下，B+TREE 永远比 B-TREE好。无限内存则后者方便</p><p>　1）B-树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B+树叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。(一次查询可能进行两次i/o操作)<br>  　 2）在B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看B-树的性能好像要比B+树好，而在实际应用中却是B+树的性能要好些。因为B+树的非叶子节点不存放实际的数据，这样每个节点可容纳的元素个数比B-树多，树高比B-树小，这样带来的好处是减少磁盘访问次数。尽管B+树找到一个记录所需的比较次数要比B-树多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中B+树的性能可能还会好些，而且B+树的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有文件，一个表中的所有记录等），这也是很多数据库和文件系统使用B+树的缘故。<br>  　<br>思考：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？ </p><ol><li>B+树的磁盘读写代价更低<br>　　B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。 </li><li>B+树的查询效率更加稳定<br>　　由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。<h3 id="建立索引的注意点"><a href="#建立索引的注意点" class="headerlink" title="建立索引的注意点"></a>建立索引的注意点</h3>​        InnoDB与MyISAM会自动为主键或者声明为UNIQE的列去自动建立B+树索引。除此之外，还需要我们自己创建索引。那么，哪些情况适合创建，哪些不适合呢？</li></ol></li></ul><p>​        创建索引的目的是希望能够快速查询。所以在建立索引之后能让查询变快，就可以考虑加索引。比如以下情况：</p><ol><li>频繁作为查询条件的字段应该创建索引</li><li>查询中与其它表关联的字段，外键关系建立索引</li><li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</li><li>查询中统计或者分组字段</li></ol><p>​        当建立索引并没有使查询变快或者反而增加了数据库空间(所以也占据空间)，那么就没有必要建立索引。比如以下情况：</p><ol><li>表记录太少</li><li>经常增删改的表。提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。</li><li>Where条件里用不到的字段不创建索引</li><li>数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。比如“性别”这一列。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引 第一篇</title>
      <link href="2021/03/24/MySQL%E7%B4%A2%E5%BC%95%20%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
      <url>2021/03/24/MySQL%E7%B4%A2%E5%BC%95%20%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么会需要索引"><a href="#为什么会需要索引" class="headerlink" title="为什么会需要索引"></a>为什么会需要索引</h3><p>​        我们在自己练习或者小系统中使用mysql数据库时，查询速度是以ms计算的。这时候我们并不需要担心查询性能。但是，当数据的量级上来时，会明显感觉到数据库的性能下降。这时候，我们就需要对数据库进行调优。<br>​       首先分析为什么性能下降，sql语句变慢呢？一个原因是查询的数据过多。第二个原因是关联了太多的表，join使用的太多。我们知道，若使用join语句，那么A表的每一条数据会扫描匹配到B表的所有数据。所以，在使用join语句时，要先过滤。第三个原因就是没有用到索引。</p><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><p>​      MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。因此，可以理解为索引是“<strong>排好序的快速查找的数据结构</strong>”。<br>​        除去数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，而且往往以索引文件的形式存储在磁盘上。这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。<br>​         索引是针对<strong>列</strong>建立索引。但并不可能每一列都建索引。索引并非越多越好。当数据更新了，索引会进行调整。也会很消耗性能。而且MySQL 并不会把所有索引都用上，只会根据其算法挑一个索引用。所以建的准也很重要。<br>​        虽然索引大大提高了查询速度，同时却会降低更新表的速度。如对表进行INSERT、UPDATE和DELETE操作，因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段。数据库都需要调整因为更新所带来的键值变化后的索引信息。索引只是提高效率的一个因素，如果MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。</p><h3 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h3><p>主键索引：设定为主键后数据库会自动建立索引，innoDB为聚簇索引<br>单值索引：即一个索引只包含单个列，一个表可以有多个单列索引<br>唯一索引：索引列的值必须唯一，但允许有空值<br>组合索引：即一个索引包含多个列</p><p>随表一起建索引：<br>CREATE TABLE customer (id INT(10) UNSIGNED  AUTO_INCREMENT ,customer_no VARCHAR(200),customer_name VARCHAR(200),<br>  <font color="blue">PRIMARY KEY(id), （主键索引）</font><br>  <font color="green">KEY (customer_name),  （单值索引）</font><br>  <font color="red">UNIQUE (customer_name),  （唯一索引）</font><br>  <font color="pink">KEY (customer_no,customer_name) (组合索引)</font><br>);</p><h3 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h3><p>​         聚簇索引不是一种索引类型，而是一种数据存储方式。术语‘聚簇’表示数据行和相邻的键值进错的存储在一起。<br>​        很简单记住一句话：找到了索引就找到了需要的数据，那么这个索引就是聚簇索引，所以主键就是聚簇索引，修改聚簇索引其实就是修改主键。<br>​        索引的存储和数据的存储是分离的，也就是说找到了索引但没找到数据，需要根据索引上的值(主键)再次回表查询,非聚簇索引也叫做辅助索引。<br>​        聚簇索引的好处：<br>​        按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大量的io操作。<br>​        聚簇索引的限制：</p><ul><li>对于mysql数据库目前只有innodb数据引擎支持聚簇索引，而Myisam并不支持聚簇索引。<br>由于数据物理存储排序方式只能有一种，所以每个Mysql的表只能有一个聚簇索引。一般情况下就是该表的主键。</li><li>为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列尽量选用有序的顺序id，而不建议用无序的id，比如uuid这种。（参考聚簇索引的好处。</li></ul><p>这里说明了主键索引为何采用自增的方式：1、业务需求，有序。2、能使用到聚簇索引</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML类图中关系</title>
      <link href="2021/03/22/UML%E7%B1%BB%E5%9B%BE/"/>
      <url>2021/03/22/UML%E7%B1%BB%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h4 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h4><p> 依赖、泛化(继承)、实现、关联、聚合以及组合。<br>继承和实现没有疑问，是类与类或者类与接口间的纵向关系；<br>其他四个的强弱程度依次为：组合&gt;聚合&gt;关联&gt;依赖。</p><h4 id="依赖关系（dependency）"><a href="#依赖关系（dependency）" class="headerlink" title="依赖关系（dependency）"></a>依赖关系（dependency）</h4><p>在类中使用到了对方，那么他们就存在依赖关系。</p><ol><li>类中用到了对方</li><li>是方法的返回类型</li><li>是类的成员属性</li><li>是方法接收的参数类型</li><li>方法中使用到</li></ol><h4 id="泛化关系（generalization）"><a href="#泛化关系（generalization）" class="headerlink" title="泛化关系（generalization）"></a>泛化关系（generalization）</h4><p>泛化关系实际上就是继承关系。是依赖关系的特例(extend)<br>如果A类继承了B类，我们就说A和B存在泛化关系。</p><h4 id="实现关系（realization）"><a href="#实现关系（realization）" class="headerlink" title="实现关系（realization）"></a>实现关系（realization）</h4><p>实现关系是A类实现B类的接口，也是依赖关系的特例</p><h4 id="关联关系（association）"><a href="#关联关系（association）" class="headerlink" title="关联关系（association）"></a>关联关系（association）</h4><p>关联关系是类与类之间的联系，也是依赖关系的特例<br>具有导航性和多重性。</p><h4 id="聚合关系（aggredation）"><a href="#聚合关系（aggredation）" class="headerlink" title="聚合关系（aggredation）"></a>聚合关系（aggredation）</h4><p>表示的是整体和部分的关系，整体与部分可以分开。即_has - a_的关系。聚合关系是关联关系的特例，所以也具有关联的导航性与多重性。</p><h4 id="组合关系（composition）"><a href="#组合关系（composition）" class="headerlink" title="组合关系（composition）"></a>组合关系（composition）</h4><p>整体与部分的关系，整体与部分不可以分开。比如身体与头之间就是组合。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于join查询</title>
      <link href="2021/03/15/%E5%85%B3%E4%BA%8Ejoin/"/>
      <url>2021/03/15/%E5%85%B3%E4%BA%8Ejoin/</url>
      
        <content type="html"><![CDATA[<h4 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h4><p>我们知道，手写sql语句大概是如下步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">&lt;select_list&gt;</span><br><span class="line">FROM</span><br><span class="line">&lt;left_table&gt;&lt;join_type&gt; </span><br><span class="line">JOIN &lt;right_table&gt; ON&lt;right_condition&gt;</span><br><span class="line">WHERE</span><br><span class="line">&lt;where_condition&gt;</span><br><span class="line">GROUP BY</span><br><span class="line">&lt;group_by_list&gt;</span><br><span class="line">HAVING</span><br><span class="line">&lt;having_condition&gt;</span><br><span class="line">ORDER BY</span><br><span class="line">&lt;order_by_condition&gt;</span><br><span class="line">LIMIT &lt;limit_number&gt;</span><br></pre></td></tr></table></figure><p>  随着Mysql版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同而动态调整执行顺序。比如，经常出现的查询顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;left_table&gt;</span><br><span class="line">ON &lt;join_condition&gt;</span><br><span class="line">&lt;join_type&gt; JOIN &lt;right_table&gt; </span><br><span class="line">WHERE&lt;where_condition&gt;</span><br><span class="line">GROUP BY &lt;group_by_list&gt;</span><br><span class="line">HAVING &lt;having_condition&gt;</span><br><span class="line">SELECT </span><br><span class="line">&lt;select_list&gt;</span><br><span class="line">ORDER BY</span><br><span class="line">&lt;order_by_condition&gt;</span><br><span class="line">LIMIT &lt;limit_number&gt;</span><br></pre></td></tr></table></figure><h4 id="join图"><a href="#join图" class="headerlink" title="join图"></a>join图</h4><p><img src="../../../Users/xuqin/Typora/1f25a82694f16316.png" alt="image.png"></p><p>共有与独有<br>共有：满足 a.deptid = b.id 的叫共有<br>A独有:  A 表中所有不满足  a.deptid = b.id  连接关系的数据</p><h4 id="七个join"><a href="#七个join" class="headerlink" title="七个join"></a>七个join</h4><p>根据共有和独有，可以知道有七中join关系：</p><ol><li><p>A、B两表共有<br> select * from t_emp a <strong>inner join</strong> t_dept b on a.deptId = b.id;</p></li><li><p>A、B两表共有+A的独有<br> select * from t_emp a <strong>left join</strong> t_dept b on a.deptId = b.id;</p></li><li><p>A、B两表共有+B的独有<br> select * from t_emp a <strong>right join</strong> t_dept b on a.deptId = b.id;</p></li><li><p>A的独有<br>select * from t_emp a <strong>left join</strong> t_dept b on a.deptId = b.id where b.id <strong>is null</strong>; </p></li><li><p>B的独有<br> select * from t_emp a <strong>right join</strong> t_dept b on a.deptId = b.id where a.deptId <strong>is null</strong>;  </p></li><li><p>AB全有<br>#MySQL Full Join的实现 因为MySQL<strong>不支持FULL JOIN</strong>,下面是替代方法<br>#替代方法: left join + union(可去除重复数据)+ right join<br>SELECT * FROM t_emp A LEFT JOIN t_dept B ON A.deptId = B.id<br>UNION<br>SELECT * FROM t_emp A RIGHT JOIN t_dept B ON A.deptId = B.id</p><p>这里因为要联合的缘故，不能考虑到小表驱动大表的情况。只能用right join。要保证查询出来的数字要一致。</p></li><li><p>A的独有+B的独有</p><p>FROM t_emp A <strong>LEFT JOIN</strong> t_dept B ON A.deptId = B.id WHERE B.<code>id</code> <strong>IS NULL</strong><br><strong>UNION</strong><br>SELECT * FROM t_emp A <strong>RIGHT JOIN</strong> t_dept B ON A.deptId = B.id WHERE A.<code>deptId</code> <strong>IS NULL</strong>;</p></li></ol><h4 id="子查询与join查询的理解"><a href="#子查询与join查询的理解" class="headerlink" title="子查询与join查询的理解"></a>子查询与join查询的理解</h4><p>子查询理解：①先知道需要查询并将数据拿出来(若from 后的表也是一个子查询结果)。②在去寻找满足判断条件的数据(where,on,having 后的参数等)。而这些查询条件通常是通过子查询获得的。</p><p>join理解：执行完第一步后的结果为一张新表。在将新表与 t_emp 进行下一步的 left join 关联。<br>先推出如何获得条件，再像算数题一样一步一步往下 join。可以交换顺序，但只能是因为条件间不相互关联时才能交换顺序。</p><p><strong>join 能用到索引，但是子查询出来的表会使索引失效。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL语句书写</title>
      <link href="2020/11/27/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2020/11/27/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="1-了解数据库和表"><a href="#1-了解数据库和表" class="headerlink" title="1. 了解数据库和表"></a>1. 了解数据库和表</h4><ul><li>连接数据库：<code>mysql -u root -p </code>（使用root权限用户登录数据库）</li><li>查看数据库：<code>show databases;</code> 或者<code>show databases\g </code> （必须用;或\g结束，仅按enter不执行命令）</li><li>选择某一数据库：<code>use case01; </code> (选择case01数据库)</li><li>查看某一数据库内的列表：<code>show tables;</code></li><li>显示表列：两种方式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">显示users表的表列:</span><br><span class="line">1.show columns from users; </span><br><span class="line">2.describe users;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小结：可以使用 help show; 查看允许的show语句。</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-检索数据-select语句"><a href="#2-检索数据-select语句" class="headerlink" title="2. 检索数据(select语句)"></a>2. 检索数据(select语句)</h4><ul><li><p><code>select *  (*被称为通配符)</code>：查到所有的列，<strong>尽量不用，降低检索效率。</strong></p></li><li><p><code>select distinct</code>：只返回不同的值</p></li><li><p><code>select...from... limit 5</code>: limit子句，返回不多于5行</p></li><li><p><code>select...from... limit 5,3</code>: limit5,3指示返回从第5行开始的3行数据。第一位是<strong>开始位置</strong>，第二位是<strong>要检索行数</strong>。</p></li><li><p><code>select...from... limit 4 offset 3</code>:从第3行开始取4行。等价于 limit 3,4.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：检索出来的第一行为0而不是行1。limit 1,1 将检索出第二行而不是第一行.</span><br></pre></td></tr></table></figure><ul><li><code>select user.name from user</code>:完全限定的名字来引用列</li><li><code>select user.name from case01.user</code>：完全限定的表名来引用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小结：select检索单个或多个表列及所有表列。limit可以限制查询行数。</span><br></pre></td></tr></table></figure><h4 id="3-排序检索-order-by子句"><a href="#3-排序检索-order-by子句" class="headerlink" title="3. 排序检索(order by子句)"></a>3. 排序检索(order by子句)</h4><ul><li><p><code>select qq from user order by qq;</code>：对qq列以qq列字母排序大小进行排序</p></li><li><p>order by子句也可以用未选择的列作为排序标准。</p><p><code>select qq from user order by email;</code>：对qq列以email列(未选择的列)字母排序大小进行排序</p></li><li><p>对多个列排序 <code>SELECT * FROM user order by gender,age;</code>:对查询结果先按性别排序，再按年龄排序。</p></li><li><p>倒序排序 desc关键字(在order by子句之后)</p><p><code>SELECT * FROM user order by age desc;</code>: 倒序查找年龄(最大的排在最前面)</p><p><code>SELECT * FROM user order by age desc,name;</code>:以降序排序年龄(最大的在前面)，然后再对名字(升序)排序</p><p><code>SELECT * FROM user order by age DESC,name DESC;</code>：以降序排序年龄(最大的在前面)，然后再对名字(降序)排序</p></li></ul><h4 id="4-搜索符合条件数据-where-子句"><a href="#4-搜索符合条件数据-where-子句" class="headerlink" title="4.  搜索符合条件数据(where 子句)"></a>4.  搜索符合条件数据(where 子句)</h4><ul><li><p>where 子句操作符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;、&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D; 字面意思</span><br><span class="line">&lt;&gt;    不等于</span><br><span class="line">!&#x3D;    不等于</span><br><span class="line">between 在指定的两个值之间</span><br></pre></td></tr></table></figure></li><li><p>检查单个值<br><code>SELECT name,age FROM user where name=&#39;QQx&#39;;</code>:查找name为qqx的user语句。(执行匹配时不区分大小写，所以QQx能与qqx匹配)</p></li><li><p>不匹配检查<br><code>SELECT name,age FROM user where age &lt;&gt; 22 ;</code>: 查询年龄不为22的user语句。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：何时使用引号：单引号用来限定字符串。所以若是查询串类型的值，需要加上引号，数值类型则不需要。</span><br></pre></td></tr></table></figure><ul><li><p>范围值检查(数值类型)<br><code>SELECT name,age FROM user where age BETWEEN 22 and 28</code>:查询年龄在22~28之间的user。</p></li><li><p>空值检查<br><code>SELECT name,age FROM user WHERE name IS NULL</code>：检查name为null值的列</p></li></ul><h4 id="5-数据过滤-where子句中-NOT与IN操作符"><a href="#5-数据过滤-where子句中-NOT与IN操作符" class="headerlink" title="5. 数据过滤(where子句中 NOT与IN操作符)"></a>5. 数据过滤(where子句中 NOT与IN操作符)</h4><ul><li><p>组合where子句(and)<br><code>SELECT name,age,gender FROM user WHERE name =&#39;赵六&#39; AND age&gt;18</code>：查询name为赵六并且年龄18岁以上的user。添加and可以组合多个过滤条件。用来检索满足所有给定条件的行。</p></li><li><p>组合where子句(or)<br><code>SELECT name,age,gender FROM user WHERE name =&#39;赵六&#39; or name=&#39;田甜&#39;</code>：查询name为赵六或者name为田甜的user。添加or用来检索满足匹配任一条件的行。</p></li><li><p>or与and计算次序<br><code>SELECT name,age,gender FROM user WHERE name =&#39;赵六&#39; or name=&#39;田甜&#39; AND age&gt;19</code>查询name为赵六 或者 name为田甜并且年龄18岁以上的user。<br><code>SELECT name,age,gender FROM user WHERE (name =&#39;赵六&#39; or name=&#39;田甜&#39; )AND age&gt;19</code> 查询name为赵六或者 name为田甜  并且年龄18岁都在以上的user。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：sql与多数语言一样，优先处理and(优先级 &amp;&amp;&gt;||)。所以在同时使用or、and操作符时，应当加上括号，消除歧义。</span><br></pre></td></tr></table></figure></li><li><p>IN操作符<br>  in操作符可以完成or相同功能，即用来指定要匹配值的清单的关键字时，功能相当。<br><code>SELECT id, name,age,gender FROM user WHERE name in (&#39;qqx&#39;,&#39;赵六&#39;,&#39;田甜&#39;)</code> :查询name在 (  ) 范围内的user。</p></li><li><p>not操作符<br><code>SELECT id, name,age,gender FROM user WHERE name NOT IN (&#39;qqx&#39;,&#39;赵六&#39;,&#39;田甜&#39;)</code>:查询name不在 (  ) 范围内的user。</p></li></ul><h4 id="6-通配符过滤-like操作符"><a href="#6-通配符过滤-like操作符" class="headerlink" title="6. 通配符过滤(like操作符)"></a>6. 通配符过滤(like操作符)</h4><ul><li><p>百分号(%)通配符：任何字符出现任意次数<br><code>SELECT id, name,age,gender FROM user WHERE name LIKE &#39;赵%&#39;</code>：查找name中以’赵’开头的词。(搜索可以不区分大小写)<br><code>SELECT id, name,qq FROM user WHERE qq LIKE &#39;%13%&#39;</code>：查找qq中包含13文本的值的所有user行。<br><code>SELECT id, name,qq FROM user WHERE qq LIKE &#39;1%3&#39;</code>查找qq中以1开头，3结尾的文本的值 的所有user行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：like不能匹配值为null的行。</span><br></pre></td></tr></table></figure></li><li><p>下划线( _ ）通配符：只能匹配一个字符<br><code>SELECT id, name FROM user WHERE name LIKE &#39;_六&#39;</code>：查找缺失第一个字符且第二个字符为六的user行<br><code>SELECT id, nameFROM user WHERE name LIKE &#39;%_六%&#39; </code></p></li></ul><h4 id="7-正则表达式搜索"><a href="#7-正则表达式搜索" class="headerlink" title="7. 正则表达式搜索"></a>7. 正则表达式搜索</h4><ul><li>简单匹配<br><code>SELECT id, name FROM user WHERE name REGEXP &#39;赵六&#39;</code>:检索含有文本’赵六’的所有user行 (等同于 like ‘%赵六%’)</li></ul><p><code>SELECT id, name FROM user WHERE name REGEXP &#39;.六&#39;</code>: .表示匹配任意一个字符</p><ul><li>进行or匹配<br><code>SELECT id, name FROM user WHERE name REGEXP &#39;赵|刘&#39;</code>：检索name中包含赵或刘文本的user行。|为正则表达式中的OR操作符。也可以给出两个以上的|。如 ‘刘|赵|王’</li></ul><p><code>SELECT id, name FROM user WHERE name REGEXP &#39;[赵刘]六&#39;</code>检索name中赵或刘且包含六的user行。可以理解为’赵|刘’ and 含有’六’。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[赵刘]六 其实是[赵|刘]六的缩写。加上[]是用来定义or语句。如果没有[],则变成了赵|刘六。这会引起歧义，事实上mysql的确会误会。</span><br><span class="line">可以把]之后想象有一个and。即[赵or刘] and 六。这其实就是or与and的计算次序问题。</span><br></pre></td></tr></table></figure><ul><li><p>匹配范围(数字范围，字符范围等)<br><code>SELECT id, name,qq FROM user WHERE qq REGEXP &#39;[1-5]66&#39;</code> 查找qq中以[1-5]范围内的文本为开头，含有66文本的user行。</p></li><li><p>匹配特殊字符(匹配  . 、 _ 、[]、|等 )<br>  使用\转义字符<br><code>SELECT id, name,qq FROM user WHERE qq REGEXP &#39;\\.&#39;:</code>查询qq列中含有 . 的user行 </p></li><li><p>匹配多个实例 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*     0个或多个匹配</span><br><span class="line">+1个或多个匹配(相当于&#123;1,&#125;)   </span><br><span class="line">?     0个或1个匹配(相当于&#123;0,1&#125;)</span><br><span class="line">&#123;n&#125;   指定数目的匹配</span><br><span class="line">&#123;n,&#125; 不少于n个数目的匹配</span><br><span class="line">&#123;n,m&#125;匹配n到m的范围(m不超过255)</span><br></pre></td></tr></table></figure></li></ul><p><code>SELECT id, name,qq FROM user WHERE name REGEXP &#39;([aq]haa?)&#39;</code>:查找name列中以a或q开头，含有ha或者<code>haa</code>(?使得a可选)的user行</p><ul><li>定位符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">^ 文本的开始</span><br><span class="line">$ 文本的结尾</span><br><span class="line">[[:&lt;:]]词的开始</span><br><span class="line">[[:&gt;:]]词的结尾</span><br></pre></td></tr></table></figure><code>SELECT id, name,qq FROM user WHERE name REGEXP &#39;[六福]$&#39;</code>查询name列以六或者福为结尾的user行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. ^ 有两种用途。[]中否定集合，还可以指串的开始</span><br><span class="line">2. like与regexp的不同在于 like匹配整个串而regexp匹配子串。</span><br><span class="line">若regexp利用 ^开头，$结尾定义表达式，则等价于like。</span><br></pre></td></tr></table></figure><h4 id="8-计算字段"><a href="#8-计算字段" class="headerlink" title="8. 计算字段"></a>8. 计算字段</h4><ul><li><p>拼接字段<br><code>select CONCAT(id,&#39;(&#39;, name,&#39;)&#39;) from user ORDER BY id;</code>：将id与(name)拼接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql拼接串使用的是concat函数，而其他数据库多数使用+或||实现。</span><br></pre></td></tr></table></figure></li><li><p>去除空格(RTrim()（右去除）、LTrim()（左去除）、Trim()（两边去除）)<br><code>select CONCAT(id,&#39;(&#39;, RTrim(name),&#39;)&#39;) from user ORDER BY id;</code> 去除name右边的所有空格后进行拼接</p></li><li><p>AS关键字<br><code>select CONCAT(id,&#39;(&#39;,RTrim(name),&#39;)&#39;) AS id_name from user ORDER BY id;</code> （实际对表没有影响） 返回一个字段为id_name 的字段，放置操作的结果</p></li><li><p>算术运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql支持基本算术操作符+-*&#x2F;，圆括号()可以用来区分顺序</span><br></pre></td></tr></table></figure><p><code>select id,quantity,price,quantity*price AS quantity_price from order where id=1000</code> 将quantity * price看做是一个字段。</p></li></ul><h4 id="9-使用函数"><a href="#9-使用函数" class="headerlink" title="9.使用函数"></a>9.使用函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数没有sql的可移植性强。不同的数据库支持不同的函数，各有差异。</span><br><span class="line">所以用函数时，需写好注释。</span><br></pre></td></tr></table></figure><ul><li>文本处理函数<br><code>select CONCAT(id,&#39;(&#39;,upper(name),&#39;)&#39;) AS id_name from user ORDER BY id</code> 将name转换成大写</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">常见的文本处理函数</span><br><span class="line">Left()返回串左边的字符</span><br><span class="line">Right()返回串右边的字符</span><br><span class="line">Lower() 将串转换成小写</span><br><span class="line">Upper()        将串转换成大写</span><br><span class="line">LTrim() 去除串左边的空格</span><br><span class="line">RTrim() 去除串右边的空格</span><br><span class="line">Length()返回串的长度</span><br><span class="line">Locate()找出串的一个子串</span><br><span class="line">Soundex() 返回串的Soundex值</span><br><span class="line">SubString()      返回子串的字符</span><br><span class="line"></span><br><span class="line">其中，soundex是一个将任何文本串转换成描述其语音表示的字母数字模式的算法。</span><br><span class="line">考虑到类似的发音字符和音节，使得能对串进行发音比较而不是字符比较。</span><br></pre></td></tr></table></figure><p><code>select id,name from user where soundex(name)=soundex(&#39;李红&#39;);</code>:匹配发音类似于李红的名字</p><ul><li>日期和时间处理函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">AddDate() 增加一个日期（天、周等）</span><br><span class="line">AddTime() 增加一个时间（时、分等）</span><br><span class="line">CurDate()返回当前日期</span><br><span class="line">CurTime()         返回当前时间</span><br><span class="line">Date()    返回日期时间的日期部分</span><br><span class="line">DateDiff()       计算两个日期之差</span><br><span class="line">Date_Add()          高度灵活的日期运算函数</span><br><span class="line">Date_Format()         返回一个格式化的日期或时间串</span><br><span class="line">Day()        返回一个日期的天数部分</span><br><span class="line">DayofWeek()  对于一个日期，返回对应的星期几</span><br><span class="line">Hour()        返回一个时间的小时部分</span><br><span class="line">Minute()    返回一个时间的分钟部分</span><br><span class="line">Month()          返回一个日期的月份部分</span><br><span class="line">NoW()                返回当前日期和时间</span><br><span class="line">Second()              返回一个时间的秒部分</span><br><span class="line">Time()                 返回一个日期时间的时间部分</span><br><span class="line">Year()      返回一个日期的年份部分</span><br></pre></td></tr></table></figure></li></ul><p><code>SELECT id,create_time from discuss_post where DATE(create_time)=&#39;2020-04-04&#39;</code> 查询给定日期部分(部分比较列中日期，因为列中可能是yyyy-MM-dd HH:mm:ss格式)</p><p><code>SELECT id,create_time from discuss_post where Year(create_time)=2019 AND Month(create_time)=7</code>:查询2019年七月的记录。</p><ul><li>数值处理函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Abs()            返回一个数的绝对值</span><br><span class="line">Cos()      返回一个角度的余弦</span><br><span class="line">Exp()      返回一个数的指数值</span><br><span class="line">Mod()返回除操作的余数</span><br><span class="line">Pi()  返回圆周率</span><br><span class="line">Rand() 返回一个随机数</span><br><span class="line">Sin() 返回一个角度的正弦</span><br><span class="line">Sqrt()  返回一个数的平方根</span><br><span class="line">Tan()返回一个角度的正切</span><br></pre></td></tr></table></figure></li></ul><h4 id="10-聚集函数"><a href="#10-聚集函数" class="headerlink" title="10. 聚集函数"></a>10. 聚集函数</h4><p>我们经常需要汇总数据而不用把它们实际检索出来，为此MySQL提供了专门的函数。使用这些函数，MySQL查询可用于检索数据，以便分析和报表生成。这种类型的检索例子有以下几种。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AVG()返回某列的平均值</span><br><span class="line">COUNT()返回某列的行数</span><br><span class="line">MAX()返回某列的最大值</span><br><span class="line">MIN()返回某列的最小值</span><br><span class="line">SUM()返回某列值之和</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>AVG() 求平均值<br><code>SELECT AVG(age) from user</code>:用户的平均年龄<br><code>SELECT AVG(age) from user where name=&#39;赵六&#39;</code>:name为赵六的人的平均年龄</p></li><li><p>COUNT()  计数<br><code>select count(*) from user</code>:对所有行计数，不管有无null值<br><code>select count(email) from user</code>:对特定行计数，null不计数。</p></li><li><p>MAX() 求最大值<br><code>select max(age) from user</code>：查询最大值</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对非数值数据使用MAX()与MIN()：</span><br><span class="line">虽然MAX() 一般用来找出最大的数值或日期值，但MySQL允许将它用来返回任意列中的最大值，包括返回文本列中的最大值。在用于文本数据时，如果数据按相应的列排序，则MAX（）返回最后一行。</span><br><span class="line">MAX()忽略列值为null的行</span><br><span class="line">MIN()与MAX()用法一样。</span><br></pre></td></tr></table></figure><ul><li><p>SUM() 求和</p><ul><li>计算指定列值的和：<code>SELECT SUM(age) from user where name=&#39;赵六&#39;</code>:对姓名为赵六的user年龄求和</li><li>合计计算值：<code>select sum(quantity*price) AS total_price from order where id=1000</code>：合计每项物品的价格，得出总价格</li></ul></li><li><p>组合聚集函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select COUNT(*) as user_nums, </span><br><span class="line">MIN(age) as age_min,</span><br><span class="line">MAX(age) as age_max,</span><br><span class="line">AVG(age) as avg_age</span><br><span class="line">from user;</span><br></pre></td></tr></table></figure><h4 id="11-分组数据"><a href="#11-分组数据" class="headerlink" title="11.分组数据"></a>11.分组数据</h4></li><li><p>group by子句<br><code>select gender,COUNT(*) from user GROUP BY gender</code>:以性别分组</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用ROLLUP：</span><br><span class="line">使用with rollup关键字，可以得到每个分组以及每个分组汇总级别(针对每个分组)的值</span><br></pre></td></tr></table></figure><ul><li>having子句<br>having与where作用类似，语法和where相同。区别是having过滤分组而where过滤行。或者说，where是在分组前进行过滤，而having是在分组后进行过滤。where排除的行不包括在分组中。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select id,count(*) AS num_prods </span><br><span class="line">from products</span><br><span class="line">where price&gt;&#x3D;10</span><br><span class="line">group by id</span><br><span class="line">having count(*) &gt; 2</span><br><span class="line"></span><br><span class="line">where先过滤行，小于10的行数先过滤，不进行分组；然后再进行having分组，统计2以上的分组。</span><br></pre></td></tr></table></figure><ul><li>分组与排序(order by与group by)<ul><li>使用group by时，应加上order by子句。因为group by排序不一定正确。</li><li>group by 如果与聚集函数一起使用列(或表达式)，则必须使用</li><li>group by 只可能使用选择列或表达式列，而且必须使用每个选择列表达式</li></ul></li></ul><h4 id="12-使用子查询"><a href="#12-使用子查询" class="headerlink" title="12. 使用子查询"></a>12. 使用子查询</h4><p>mysql中，子查询是从内向外处理。</p><ul><li><p>利用子查询进行过滤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name,cust_contact </span><br><span class="line">FROM customers </span><br><span class="line">WHERE cuSt_id IN(SELECT cuSt_id </span><br><span class="line">FROM orders </span><br><span class="line">WHERE order_num IN(SELECT order_num </span><br><span class="line">FROM orderitems </span><br><span class="line">WHERE prod_id&#x3D;&quot;TNT2&#39;));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是select语句具有与where子句中相同数目的列。</p></li><li><p>作为计算字段使用子查询</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>踩坑日常——博客搭建(Hexo+node.js)</title>
      <link href="2020/10/23/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA(Hexo+node.js)/"/>
      <url>2020/10/23/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA(Hexo+node.js)/</url>
      
        <content type="html"><![CDATA[<p>搭建一个Hexo静态博客所需要安装的有 Node.js和Hexo以及git环境。上传的(免费)服务器可以选择github、gitee、coding等。我选择的是<strong>gitee</strong>。我的电脑环境是win10，所以安装git之后，在git bash里面可以用Linux命令。安装的步骤教程网上有很多，这里我就不赘述。主要记录一下配置过程中所遇到的几处<strong>问题</strong>以及我解决的方案(不一定是<strong>最优解</strong>)。</p><hr><h4 id="一：标签about里面的内容写出来不能识别"><a href="#一：标签about里面的内容写出来不能识别" class="headerlink" title="一：标签about里面的内容写出来不能识别"></a>一：标签about里面的内容写出来不能识别</h4><p>在按照网上大部分配置首页，分类，标签这种页面的步骤配置之后，</p><p>我发现about这一栏我出现了问题。于是去找关于文章写作的相关命令。</p><p>排查错误之后，发现是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: about</span><br><span class="line">type: about</span><br><span class="line">layout: &quot;about&quot;</span><br></pre></td></tr></table></figure><p>这一部分的错误。原因是yml的格式，<strong>需要在：之后打上空格。</strong></p><p>所以，不论是配置类，如<strong>_config.yml</strong>文件还是在写博客的<strong>md</strong>文件中，冒号之后需要配置的记得来一个空格。</p><hr><h4 id="二、本地文件不能与gitee上同步"><a href="#二、本地文件不能与gitee上同步" class="headerlink" title="二、本地文件不能与gitee上同步"></a>二、本地文件不能与gitee上同步</h4><p> 最大的问题就是这个了。为了解决这个问题花了两天时间…</p><p>一开始配置好的时候就一股脑的上传了，然后改主题，写了测试博客。在本地运行<strong>hexo c (清除缓存)**和</strong>hexo g(生成静态文件)** 以及 <strong>hexo s(本地运行)</strong></p><p>之后，在本地输入<strong>localhost:4000</strong>(默认此端口)之后就可以进行博客的预览了。这几步进行下来比较顺利。可是在部署在远程服务器这一步出现了问题。</p><p>我根据主题改成的自己的博客发布上去之后，访问到的还是之前的主题。也就是说，我的页面并没有更改。查找了一些相关博文以及问答之后，我进行了重新部署。具体是根据这篇 <a href="https://blog.csdn.net/GAI159/article/details/105128186">https://blog.csdn.net/GAI159/article/details/105128186</a>对于分支进行了修改。</p><p>一般情况下，在git中使用命令hexo c &amp;&amp; hexo g - d发布上去就行了。但是我试了很多也找了好多博文跟着做也不行。</p><p>最后解决方案：更新博客或者删除之后，hexo g-d(这样上传到gitee的master分支上)，然后再在gitee pages服务那里，点击更新重新部署。</p><p>这样很麻烦，目前的问题就是发布在gitee上是有更新的，但是网站不能更新。暂时的方法只有这样了。</p><hr><h4 id="三、使用个人域名"><a href="#三、使用个人域名" class="headerlink" title="三、使用个人域名"></a>三、使用个人域名</h4><p><a href="https://xq2000.gitee.io/">https://xq2000.gitee.io</a> 这样的名字不太好听(gitee提供的免费服务器)。所以我决定申请一个域名。这里又是一个摸石头过河的过程……</p><p>首先，我所知道的平台就是github、gitee以及coding(自建服务器不考虑)。本来我的代码仓库放在gitee上的，国内毕竟访问什么的不受限制。所以当我兴冲冲的申请好域名之后……gitee上面居然要升级Gitee Page Pro才能加入个人域名(90多一年呢……)于是我又去coding。在coding上，我们发布博客除了配置个人域名，添加域名解析记录以及申请SSL证书以外，还需要开启CDN功能。</p><h5 id="CDN功能"><a href="#CDN功能" class="headerlink" title="CDN功能"></a>CDN功能</h5><p>CDN功能开启有相应的计费说明和文档(没错，需要付费。不过有送的128G流量包)。域名接入 CDN 后，系统会自动分配一个以 <code>.cdn.dnsv1.com</code> 为后缀的 CNAME 域名，可在 CDN 控制台 <a href="https://console.cloud.tencent.com/cdn/domains">域名管理页</a> 查看。CNAME 域名不能直接访问，需要在域名服务提供商处完成 CNAME 配置。</p><h5 id="自定义域名添加"><a href="#自定义域名添加" class="headerlink" title="自定义域名添加"></a>自定义域名添加</h5><p>CDN开启后，就可以加入自定义域名了。CDN的服务还没有开启，需要接入域名。可以先配置域名，之后接入CDN。</p><p>输入你的域名，绑定即可。添加好个人域名之后，会自动去申请SSL证书。</p><p><img src="https://s1.ax1x.com/2020/10/02/0ldgF1.png" alt="0ldgF1.png"></p><hr><h5 id="添加域名解析记录"><a href="#添加域名解析记录" class="headerlink" title="添加域名解析记录"></a>添加域名解析记录</h5><p>域名添加好之后，需要去为域名添加CNAME记录。<img src="https://s1.ax1x.com/2020/10/02/0ld9G6.png" alt="0ld9G6.png"></p><p><img src="https://s1.ax1x.com/2020/10/02/0ldXSf.png" alt="0ldXSf.png"></p><p>这里的记录值(也就是CNAME指向)是需要复制到CNAME记录中去的。</p><p>显示审核中就是你需要去添加的CNAME记录。</p><p>去到对应的域名托管处进行添加。我用的是腾讯云。</p><p><img src="https://s1.ax1x.com/2020/10/02/0ldGZj.png" alt="0ldGZj.png"></p><p>主机记录填写之前填写的域名前缀（例如：blog.okok.host 填写 blog），也可以填上**@<strong>。记录类型填写 **CNAME</strong>，记录值填写域名列表中的 CNAME 指向(也是上面画红线的记录值)（例如：niqux.top.cdn.dnv1.com）</p><h5 id="SSL证书"><a href="#SSL证书" class="headerlink" title="SSL证书"></a>SSL证书</h5><p>配置好之后，如果你的域名服务状态和DNS状态显示不正常，那么就需要申请SSL证书。(在配置个人域名那一步的时候，会自动去申请SSL证书)。这里显示待验证状态的，就是刚才申请的域名所对应的SSL证书了。我是在腾讯云上申请的域名，所以相应的SSL证书是在腾讯云上发布的。一般一个工作日就可以了。</p><p><img src="https://s1.ax1x.com/2020/10/02/0ldRW6.png" alt="0ldRW6.png"></p><hr><p>所有都配置好没有错误之后，重新部署你的项目即可。</p><p>详细可在coding帮助文档查找：<a href="https://help.coding.net/docs/cd/static-website-v2.html?_ga=2.68172817.1030326411.1601571268-1149512744.1601571268#%E6%B7%BB%E5%8A%A0%E8%A7%A3%E6%9E%90%E8%AE%B0%E5%BD%95">https://help.coding.net/docs/cd/static-website-v2.html?_ga=2.68172817.1030326411.1601571268-1149512744.1601571268#%E6%B7%BB%E5%8A%A0%E8%A7%A3%E6%9E%90%E8%AE%B0%E5%BD%95</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 踩坑日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring学习笔记 之一</title>
      <link href="2020/09/17/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
      <url>2020/09/17/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring的优势"><a href="#Spring的优势" class="headerlink" title="Spring的优势"></a>Spring的优势</h2><ol><li>低侵入式设计，代码污染极低</li><li>独立于各种应用服务器，基于Spring框架的应用，可以真正实现Write Once,Run Anywhere的承诺</li><li>Spring的DI机制降低了业务对象替换的复杂性，提高了组件之间的解耦</li><li>Spring的AOP支持允许将一些通用任务如安全、事务、日志等进行集中式管理，从而提供了更好的复用</li><li>Spring的ORM和DAO提供了与第三方持久层框架的良好整合，并简化了底层的数据库访问</li><li>Spring并不强制应用完全依赖于Spring，开发者可自由选用Spring框架的部分或全部       </li></ol><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>首先，程序讲究的是<strong>低耦合，高内聚</strong></p><ul><li>解耦的方式：工厂模式解耦</li><li>工厂：负责从容器中获取指定对象的类</li><li>Bean Factory：一个创建Bean对象的工厂</li></ul><ol><li>Bean的含义:是可重用组件的含义。</li><li>javaBean与实体类之间的区别<br>javaBean：用java语言编写的可重用组件<br>javabean &gt; 实体类</li></ol><ul><li><p>之前是采用new的方式，是主动的<br><img src="../../../Users/xuqin/Typora/eff3cd7ca28f2580.png" alt="image-20200908215200562.png"></p></li><li><p>使用工厂之后，需要工厂为程序查找或创建对象，是被动的。<br><img src="../../../Users/xuqin/Typora/2c4c3e70d8be25c9.png" alt="image-20200908215244947.png"></p></li></ul><p>这种被动接收的方式获取对象的思想就是<strong>控制反转</strong>，它是 spring 框架的核心之一。 </p><h2 id="控制反转-IoC"><a href="#控制反转-IoC" class="headerlink" title="控制反转(IoC)"></a>控制反转(IoC)</h2><p><strong>控制反转</strong>（Inversion of Control，缩写为<strong>IoC</strong>），是面向对象编程)中的一种设计原则，可以用来减低计算机代码之间的耦合度。</p><p>Spring Framework提供IoC容器。</p><p>明确 Ioc的作用：  <strong>削减计算机程序的耦合(解除我们代码中的依赖关系)。</strong> </p><p>是<strong>削减</strong>，而不能完全去除耦合。</p><h3 id="IoC包括依赖注入和依赖查找两种方式-重点"><a href="#IoC包括依赖注入和依赖查找两种方式-重点" class="headerlink" title="IoC包括依赖注入和依赖查找两种方式(重点)"></a>IoC包括<strong>依赖注入</strong>和<strong>依赖查找</strong>两种方式(重点)</h3><p>1.核心容器的两个接口BeanFactory和 ApplicationContext 的区别：</p><pre><code>     BeanFactory 才是 Spring 容器中的顶层接口。     ApplicationContext 是它的子接口。</code></pre><p>​    他们创建对象的时间点不一样： </p><ul><li><p>ApplicationContext：单例对象适用(实际采用此接口)<br>它在构建核心容器时，创建对象采用的策略是立刻加载的方式，</p><p>也就是说，只要一读取配置文件，就会创建出配置文件中配置的对象。</p></li><li><p>BeanFactory：             多例对象适用<br>它在构建核心容器时，创建对象采取的策略是采用延迟加载的方式，</p><p>也就是说，什么时候根据id获取对象，需要创建对象的时候才会真正的去创建对象。</p></li></ul><h3 id="ApplicationContext-接口的实现类"><a href="#ApplicationContext-接口的实现类" class="headerlink" title="ApplicationContext 接口的实现类"></a>ApplicationContext 接口的实现类</h3><p>ClassPathXmlApplicationContext：  它是从类的根路径下加载配置文件  (推荐使用这种) </p><p>FileSystemXmlApplicationContext：  它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。</p><p> AnnotationConfigApplicationContext: 当我们使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。 </p><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><p>@Component 标注一个类为Spring容器的Bean，（把普通pojo实例化到spring容器中，相当于配置文件中的<bean id="" class=""/>）</p><p>@Controller(一般用于表现层)</p><p>@Service (一般用于业务层)</p><p>@Repository(一般用于持久层) 用于注入数据</p><p>@Autowired 实现依赖注入，按by type自动注入</p><p>@Qualifier (给字段注入时不能独立使用，必须和 @Autowire 一起使用；但是给方法参数注入时，可以独立使用)</p><p>@Resource 实现依赖注入，按byName自动注入</p><p>@Value 通过注解将常量、配置文件中的值、其他bean的属性值注入到变量中，作为变量的初始值</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring学习笔记 之一</title>
      <link href="2020/02/10/JDBC%E7%9F%A5%E8%AF%86/"/>
      <url>2020/02/10/JDBC%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="JDBC基础"><a href="#JDBC基础" class="headerlink" title="JDBC基础"></a>JDBC基础</h2><h4 id="1-概念："><a href="#1-概念：" class="headerlink" title="1. 概念："></a>1. 概念：</h4><p>Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库</p><ul><li>JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。<h4 id="2-快速入门："><a href="#2-快速入门：" class="headerlink" title="2. 快速入门："></a>2. 快速入门：</h4></li></ul><ul><li><p>步骤：</p><ol><li>导入驱动jar包 mysql-connector-java-5.1.37-bin.jar</li></ol><ul><li>复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下</li><li>右键–&gt;Add As Library</li></ul><ol start="2"><li>注册驱动</li><li>获取数据库连接对象 Connection</li><li>定义sql</li><li>获取执行sql语句的对象 Statement</li><li>执行sql，接受返回结果</li><li>处理结果</li><li>释放资源</li></ol><ul><li>代码实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 导入驱动jar包</span></span><br><span class="line"><span class="comment">//2.注册驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"><span class="comment">//3.获取数据库连接对象</span></span><br><span class="line">Connection conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/db3&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line"><span class="comment">//4.定义sql语句</span></span><br><span class="line">String sql = <span class="string">&quot;update account set balance = 500 where id = 1&quot;</span>;</span><br><span class="line"><span class="comment">//5.获取执行sql的对象 Statement</span></span><br><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line"><span class="comment">//6.执行sql</span></span><br><span class="line"><span class="keyword">int</span> count = stmt.executeUpdate(sql);</span><br><span class="line"><span class="comment">//7.处理结果</span></span><br><span class="line">System.out.println(count);</span><br><span class="line"><span class="comment">//8.释放资源</span></span><br><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure><h4 id="3-详解各个对象："><a href="#3-详解各个对象：" class="headerlink" title="3. 详解各个对象："></a>3. 详解各个对象：</h4><h5 id="1-DriverManager：驱动管理对象"><a href="#1-DriverManager：驱动管理对象" class="headerlink" title="1. DriverManager：驱动管理对象"></a>1. DriverManager：驱动管理对象</h5></li></ul></li><li><p>功能：</p><ol><li><p>注册驱动：告诉程序该使用哪一个数据库驱动jar<br> <code>static void registerDriver(Driver driver)</code> :注册与给定的驱动程序 DriverManager 。<br> 写代码使用：  <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code><br> 通过查看源码发现：在<code>com.mysql.jdbc.Driver</code>类中存在静态代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">   java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">   &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。</p></li><li><p>获取数据库连接：</p></li></ol><ul><li>方法：<code>static Connection getConnection(String url, String user, String password) </code></li><li>参数：<ul><li>url：指定连接的路径<ul><li>语法：<code>jdbc:mysql://ip地址(域名):端口号/数据库名称</code><ul><li>例子：<code>jdbc:mysql://localhost:3306/db3</code></li><li>细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称</li><li>user：用户名</li><li>password：密码 <h5 id="2-Connection：数据库连接对象"><a href="#2-Connection：数据库连接对象" class="headerlink" title="2. Connection：数据库连接对象"></a>2. Connection：数据库连接对象</h5>功能：</li></ul></li></ul></li></ul></li></ul><ol><li>获取执行sql 的对象</li></ol><ul><li><code>Statement createStatement()</code><ul><li><code>PreparedStatement prepareStatement(String sql)  </code></li></ul></li></ul><ol start="2"><li>管理事务：</li></ol><ul><li>开启事务：<code>setAutoCommit(boolean autoCommit)</code> ：调用该方法设置参数为false，即开启事务<ul><li>提交事务：<code>commit() </code></li><li>回滚事务：<code>rollback() </code></li></ul></li></ul></li></ul><h5 id="3-Statement：执行sql的对象"><a href="#3-Statement：执行sql的对象" class="headerlink" title="3. Statement：执行sql的对象"></a>3. Statement：执行sql的对象</h5><ol><li>执行sql<ol><li><code>boolean execute(String sql)</code> ：可以执行任意的sql 了解 </li><li><code>int executeUpdate(String sql) </code>：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句</li></ol><ul><li>返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。<ol start="3"><li><code>ResultSet executeQuery(String sql) </code> ：执行DQL（select)语句</li></ol></li></ul></li></ol><h5 id="4-ResultSet：结果集对象-封装查询结果"><a href="#4-ResultSet：结果集对象-封装查询结果" class="headerlink" title="4. ResultSet：结果集对象,封装查询结果"></a>4. ResultSet：结果集对象,封装查询结果</h5><ul><li><p>boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true</p></li><li><p>getXxx(参数):获取数据</p><pre><code>      * Xxx：代表数据类型   如： int getInt() ,    String getString()      * 参数：          1. int：代表列的编号,从1开始   如： getString(1)      2. String：代表列名称。 如： getDouble(&quot;balance&quot;)  * 注意：      * 使用步骤：          1. 游标向下移动一行          2. 判断是否有数据          3. 获取数据         //循环判断游标是否是最后一行末尾。    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">          <span class="comment">//获取数据</span></span><br><span class="line">      <span class="comment">//6.2 获取数据</span></span><br><span class="line">          <span class="keyword">int</span> id = rs.getInt(<span class="number">1</span>);</span><br><span class="line">          String name = rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">          <span class="keyword">double</span> balance = rs.getDouble(<span class="number">3</span>);</span><br><span class="line">          System.out.println(id + <span class="string">&quot;---&quot;</span> + name + <span class="string">&quot;---&quot;</span> + balance);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><h5 id="5-PreparedStatement：执行sql的对象"><a href="#5-PreparedStatement：执行sql的对象" class="headerlink" title="5. PreparedStatement：执行sql的对象"></a>5. PreparedStatement：执行sql的对象</h5><ol><li><p>SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题</p><pre><code> 1. 输入用户随便，输入密码：a&#39; or &#39;a&#39; = &#39;a 2. sql：select * from user where username = &#39;fhdsjkf&#39; and password = &#39;a&#39; or &#39;a&#39; = &#39;a&#39; </code></pre></li><li><p>解决sql注入问题：使用PreparedStatement对象来解决</p></li><li><p>预编译的SQL：参数使用?作为占位符</p></li><li><p>步骤：</p><ol><li>导入驱动jar包 mysql-connector-java-5.1.37-bin.jar</li><li>注册驱动</li><li>获取数据库连接对象 Connection</li><li>定义sql</li></ol><ul><li>注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;</li></ul><ol start="5"><li>获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql) </li><li>给？赋值：</li></ol><ul><li>方法： setXxx(参数1,参数2)</li><li>参数1：？的位置编号 从1 开始</li><li>参数2：？的值</li></ul><ol start="7"><li>执行sql，接受返回结果，不需要传递sql语句</li><li>处理结果</li><li>释放资源</li></ol></li><li><p>注意：后期都会使用PreparedStatement来完成增删改查的所有操作</p><ol><li>可以防止SQL注入</li><li>效率更高</li></ol></li></ol><h2 id="抽取JDBC工具类-：-JDBCUtils"><a href="#抽取JDBC工具类-：-JDBCUtils" class="headerlink" title="抽取JDBC工具类 ： JDBCUtils"></a>抽取JDBC工具类 ： JDBCUtils</h2><ul><li><p>目的：简化书写</p></li><li><p>分析：</p><ol><li>注册驱动也抽取</li><li>抽取一个方法获取连接对象</li></ol><ul><li>需求：不想传递参数（麻烦），还得保证工具类的通用性。</li><li>解决：配置文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.properties</span><br><span class="line">url&#x3D;</span><br><span class="line">user&#x3D;</span><br><span class="line">password&#x3D;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><p>抽取一个方法释放资源</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> String user;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> String driver;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">static</span>&#123;</span><br><span class="line">           <span class="comment">//读取资源文件，获取值。</span></span><br><span class="line">   </span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//1. 创建Properties集合类。</span></span><br><span class="line">               Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">   </span><br><span class="line">               <span class="comment">//获取src路径下的文件的方式---&gt;ClassLoader 类加载器</span></span><br><span class="line">               ClassLoader classLoader = JDBCUtils.class.getClassLoader();</span><br><span class="line">               URL res  = classLoader.getResource(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">               String path = res.getPath();</span><br><span class="line">               System.out.println(path);<span class="comment">///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties</span></span><br><span class="line">               <span class="comment">//2. 加载文件</span></span><br><span class="line">              <span class="comment">// pro.load(new FileReader(&quot;D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties&quot;));</span></span><br><span class="line">               pro.load(<span class="keyword">new</span> FileReader(path));</span><br><span class="line">   </span><br><span class="line">               <span class="comment">//3. 获取数据，赋值</span></span><br><span class="line">               url = pro.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">               user = pro.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">               password = pro.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">               driver = pro.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">               <span class="comment">//4. 注册驱动</span></span><br><span class="line">               Class.forName(driver);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 连接对象</span></span><br><span class="line"><span class="comment">     */</span>   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stmt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Statement stmt,Connection conn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( stmt != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stmt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs,Statement stmt, Connection conn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( rs != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( stmt != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="JDBC控制事务："><a href="#JDBC控制事务：" class="headerlink" title="JDBC控制事务："></a>JDBC控制事务：</h2><ol><li><p>事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。</p></li><li><p>操作：</p><ol><li>开启事务</li><li>提交事务</li><li>回滚事务</li></ol></li><li><p>使用Connection对象来管理事务</p><ul><li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务<ul><li>在执行sql之前开启事务</li></ul></li><li>提交事务：commit() <ul><li>当所有sql都执行完提交事务</li></ul></li><li>回滚事务：rollback() <ul><li>在catch中回滚事务</li></ul></li></ul><ol start="4"><li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCDemo10</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement pstmt1 = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement pstmt2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取连接</span></span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            <span class="comment">//开启事务</span></span><br><span class="line">            conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.定义sql</span></span><br><span class="line">            <span class="comment">//2.1 张三 - 500</span></span><br><span class="line">            String sql1 = <span class="string">&quot;update account set balance = balance - ? where id = ?&quot;</span>;</span><br><span class="line">            <span class="comment">//2.2 李四 + 500</span></span><br><span class="line">            String sql2 = <span class="string">&quot;update account set balance = balance + ? where id = ?&quot;</span>;</span><br><span class="line">            <span class="comment">//3.获取执行sql对象</span></span><br><span class="line">            pstmt1 = conn.prepareStatement(sql1);</span><br><span class="line">            pstmt2 = conn.prepareStatement(sql2);</span><br><span class="line">            <span class="comment">//4. 设置参数</span></span><br><span class="line">            pstmt1.setDouble(<span class="number">1</span>,<span class="number">500</span>);</span><br><span class="line">            pstmt1.setInt(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            pstmt2.setDouble(<span class="number">1</span>,<span class="number">500</span>);</span><br><span class="line">            pstmt2.setInt(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">            <span class="comment">//5.执行sql</span></span><br><span class="line">            pstmt1.executeUpdate();</span><br><span class="line">            <span class="comment">// 手动制造异常</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">3</span>/<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            pstmt2.executeUpdate();</span><br><span class="line">            <span class="comment">//提交事务</span></span><br><span class="line">            conn.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//事务回滚</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    conn.rollback();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.close(pstmt1,conn);</span><br><span class="line">            JDBCUtils.close(pstmt2,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaweb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识泛型</title>
      <link href="2020/01/23/%E6%B3%9B%E5%9E%8B/"/>
      <url>2020/01/23/%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="泛型概述"><a href="#泛型概述" class="headerlink" title="泛型概述"></a>泛型概述</h2><p>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p><p>观察下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">coll.add(<span class="number">5</span>);<span class="comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span></span><br><span class="line">Iterator it = coll.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line"><span class="comment">//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span></span><br><span class="line">String str = (String) it.next();</span><br><span class="line">System.out.println(str.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序在运行时发生了问题<strong>java.lang.ClassCastException</strong>。                                                                                             为什么会发生类型转换异常呢？                                                                                                                                       我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。                                                                                                                                                       怎么来解决这个问题呢？                                                                                                                                                           Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了<strong>泛型</strong>(<strong>Generic</strong>)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p><ul><li><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</li></ul><blockquote><p>tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p></blockquote><h2 id="使用泛型的好处"><a href="#使用泛型的好处" class="headerlink" title="使用泛型的好处"></a>使用泛型的好处</h2><p>那么泛型带来了哪些好处呢？</p><ul><li>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</li><li>避免了类型强转的麻烦。</li></ul><p>通过如下代码体验一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        <span class="comment">// list.add(5);//当集合明确类型后，存放类型不一致就会编译报错</span></span><br><span class="line">        <span class="comment">// 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            String str = it.next();</span><br><span class="line">            <span class="comment">//当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型</span></span><br><span class="line">            System.out.println(str.length());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</p></blockquote><h2 id="泛型的定义与使用"><a href="#泛型的定义与使用" class="headerlink" title="泛型的定义与使用"></a>泛型的定义与使用</h2><p>我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。<br>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p><h3 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h3><p>定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 类名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，API中的ArrayList集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123; &#125;</span><br><span class="line">   ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用泛型： 即什么时候确定泛型。</p><p><strong>在创建对象的时候确定泛型</strong></p><p> 例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p><p>此时，变量E的值就是String类型,那么我们的类型就可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt;</span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(String e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再例如，<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></p><p>此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">Integer</span>&gt; </span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Integer e)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例自定义泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericClass</span>&lt;<span class="title">MVP</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型</span></span><br><span class="line"><span class="keyword">private</span> MVP mvp;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMVP</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mvp = mvp;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> MVP <span class="title">getMVP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClassDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">         <span class="comment">// 创建一个泛型为String的类</span></span><br><span class="line">         MyGenericClass&lt;String&gt; my = <span class="keyword">new</span> MyGenericClass&lt;String&gt;();    </span><br><span class="line">         <span class="comment">// 调用setMVP</span></span><br><span class="line">         my.setMVP(<span class="string">&quot;大胡子登登&quot;</span>);</span><br><span class="line">         <span class="comment">// 调用getMVP</span></span><br><span class="line">         String mvp = my.getMVP();</span><br><span class="line">         System.out.println(mvp);</span><br><span class="line">         <span class="comment">//创建一个泛型为Integer的类</span></span><br><span class="line">         MyGenericClass&lt;Integer&gt; my2 = <span class="keyword">new</span> MyGenericClass&lt;Integer&gt;(); </span><br><span class="line">         my2.setMVP(<span class="number">123</span>);     </span><br><span class="line">         Integer mvp2 = my2.getMVP();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericMethod</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">    System.out.println(mvp.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function">MVP <span class="title">show2</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用格式：<strong>调用方法时，确定泛型的类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        MyGenericMethod mm = <span class="keyword">new</span> MyGenericMethod();</span><br><span class="line">        <span class="comment">// 演示看方法提示</span></span><br><span class="line">        mm.show(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        mm.show(<span class="number">123</span>);</span><br><span class="line">        mm.show(<span class="number">12.45</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface接口名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> E <span class="title">getE</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用格式：</p><p><strong>1、定义类时确定泛型的类型</strong></p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp1</span> <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，泛型E的值就是String类型。</p><p> <strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p><p> 例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp2</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确定泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyImp2&lt;String&gt;  my = <span class="keyword">new</span> MyImp2&lt;String&gt;();  </span><br><span class="line">        my.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p><h4 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h4><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p><p>此时只能接受数据,不能往该集合中存储数据。</p><p>举个例子大家理解使用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Intger&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    getElement(list1);</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    getElement(list2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement</span><span class="params">(Collection&lt;?&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//？代表可以接收任意类型</span></span><br></pre></td></tr></table></figure><blockquote><p>tips:泛型不存在继承关系 Collection<Object> list = new ArrayList<String>();这种是错误的。</p></blockquote><h4 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h4><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p><p><strong>泛型的上限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li></ul><p><strong>泛型的下限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li></ul><p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    Collection&lt;Number&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">    Collection&lt;Object&gt; list4 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    </span><br><span class="line">    getElement(list1);</span><br><span class="line">    getElement(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement(list3);</span><br><span class="line">    getElement(list4);<span class="comment">//报错</span></span><br><span class="line">  </span><br><span class="line">    getElement2(list1);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list3);</span><br><span class="line">    getElement2(list4);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement2</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识Collection集合</title>
      <link href="2020/01/21/java%E5%9F%BA%E7%A1%80-Collection%E3%80%81%E6%B3%9B%E5%9E%8B/"/>
      <url>2020/01/21/java%E5%9F%BA%E7%A1%80-Collection%E3%80%81%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-Collection集合"><a href="#第一章-Collection集合" class="headerlink" title="第一章 Collection集合"></a>第一章 Collection集合</h1><h2 id="1-1-集合概述"><a href="#1-1-集合概述" class="headerlink" title="1.1 集合概述"></a>1.1 集合概述</h2><p>在前面基础班我们已经学习过并使用过集合ArrayList<E> ,那么集合到底是什么呢?</p><ul><li><strong>集合</strong>：集合是java中提供的一种容器，可以用来存储多个数据。</li></ul><p>集合和数组既然都是容器，它们有啥区别呢？</p><ul><li>数组的长度是固定的。集合的长度是可变的。</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li></ul><h2 id="1-2-集合框架"><a href="#1-2-集合框架" class="headerlink" title="1.2  集合框架"></a>1.2  集合框架</h2><p>JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p><p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code>，今天我们主要学习<code>Collection</code>集合，在day04时讲解<code>Map</code>集合。</p><ul><li><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是元素有序、元素可重复。<code>Set</code>的特点是元素无序，而且不可重复。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</li></ul><p>从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。</p><p><img src="img%5CCollection%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E5%9B%BE.png"></p><p>其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。</p><p>集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最最共性的内容。</p><h2 id="1-3-Collection-常用功能"><a href="#1-3-Collection-常用功能" class="headerlink" title="1.3 Collection 常用功能"></a>1.3 Collection 常用功能</h2><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法(共性方法)，这些方法可用于操作所有的单列集合。方法如下：</p><ul><li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code> :清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li><li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li><li><code>public int size()</code>: 返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li></ul><p>方法演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1Collection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建集合对象 </span></span><br><span class="line">    <span class="comment">// 使用多态形式</span></span><br><span class="line">    Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">// 使用方法</span></span><br><span class="line">    <span class="comment">// 添加功能  boolean  add(String s)</span></span><br><span class="line">    coll.add(<span class="string">&quot;小李广&quot;</span>);</span><br><span class="line">    coll.add(<span class="string">&quot;扫地僧&quot;</span>);</span><br><span class="line">    coll.add(<span class="string">&quot;石破天&quot;</span>);</span><br><span class="line">    System.out.println(coll);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// boolean contains(E e) 判断o是否在集合中存在</span></span><br><span class="line">    System.out.println(<span class="string">&quot;判断  扫地僧 是否在集合中&quot;</span>+coll.contains(<span class="string">&quot;扫地僧&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean remove(E e) 删除在集合中的o元素</span></span><br><span class="line">    System.out.println(<span class="string">&quot;删除石破天：&quot;</span>+coll.remove(<span class="string">&quot;石破天&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;操作之后集合中元素:&quot;</span>+coll);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// size() 集合中有几个元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;集合中有&quot;</span>+coll.size()+<span class="string">&quot;个元素&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object[] toArray()转换成一个Object数组</span></span><br><span class="line">    Object[] objects = coll.toArray();</span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">System.out.println(objects[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void  clear() 清空集合</span></span><br><span class="line">coll.clear();</span><br><span class="line">System.out.println(<span class="string">&quot;集合中内容为：&quot;</span>+coll);</span><br><span class="line"><span class="comment">// boolean  isEmpty()  判断是否为空</span></span><br><span class="line">System.out.println(coll.isEmpty());  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。</p></blockquote><h2 id="第二章-Iterator迭代器"><a href="#第二章-Iterator迭代器" class="headerlink" title="第二章 Iterator迭代器"></a>第二章 Iterator迭代器</h2><h2 id="2-1-Iterator接口"><a href="#2-1-Iterator接口" class="headerlink" title="2.1 Iterator接口"></a>2.1 Iterator接口</h2><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p><p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p><ul><li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li></ul><p>下面介绍一下迭代的概念：</p><ul><li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li></ul><p>Iterator接口的常用方法如下：</p><ul><li><code>public E next()</code>:返回迭代的下一个元素。</li><li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li></ul><p>接下来我们通过案例学习如何使用Iterator迭代集合中元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用多态方式 创建对象</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素到集合</span></span><br><span class="line">        coll.add(<span class="string">&quot;串串星人&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;吐槽星人&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;汪星人&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//使用迭代器 遍历   每个集合对象都有自己的迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="comment">//  泛型指的是 迭代出 元素的数据类型</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">            String s = it.next();<span class="comment">//获取迭代出的元素</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。</p></blockquote><h2 id="2-2-迭代器的实现原理"><a href="#2-2-迭代器的实现原理" class="headerlink" title="2.2 迭代器的实现原理"></a>2.2 迭代器的实现原理</h2><p>我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p><p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程：</p><p><img src="img%5C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8E%9F%E7%90%86%E5%9B%BE.bmp"></p><p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p><h2 id="2-3-增强for"><a href="#2-3-增强for" class="headerlink" title="2.3 增强for"></a>2.3 增强for</h2><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; </span><br><span class="line">  <span class="comment">//写操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p><h4 id="练习1：遍历数组"><a href="#练习1：遍历数组" class="headerlink" title="练习1：遍历数组"></a>练习1：遍历数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBForDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">87</span>&#125;;</span><br><span class="line">       <span class="comment">//使用增强for遍历数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a : arr)&#123;<span class="comment">//a代表数组中的每个元素</span></span><br><span class="line">System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习2-遍历集合"><a href="#练习2-遍历集合" class="headerlink" title="练习2:遍历集合"></a>练习2:遍历集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">    Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    coll.add(<span class="string">&quot;小河神&quot;</span>);</span><br><span class="line">    coll.add(<span class="string">&quot;老河神&quot;</span>);</span><br><span class="line">    coll.add(<span class="string">&quot;神婆&quot;</span>);</span><br><span class="line">    <span class="comment">//使用增强for遍历</span></span><br><span class="line">    <span class="keyword">for</span>(String s :coll)&#123;<span class="comment">//接收变量s代表 代表被遍历到的集合元素</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object类及常用的API</title>
      <link href="2020/01/17/java%E5%9F%BA%E7%A1%80-Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API/"/>
      <url>2020/01/17/java%E5%9F%BA%E7%A1%80-Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-Object类"><a href="#第一章-Object类" class="headerlink" title="第一章 Object类"></a>第一章 Object类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><code>java.lang.Object</code>类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。</p><p>如果一个类没有特别指定父类，    那么默认则继承自Object类。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> /*<span class="keyword">extends</span> <span class="title">Object</span>*/ </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个：</p><ul><li><code>public String toString()</code>：返回该对象的字符串表示。</li><li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li></ul><h2 id="1-2-toString方法"><a href="#1-2-toString方法" class="headerlink" title="1.2 toString方法"></a>1.2 toString方法</h2><h3 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul><li><code>public String toString()</code>：返回该对象的字符串表示。</li></ul><p>toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。</p><p>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。</p><h3 id="覆盖重写"><a href="#覆盖重写" class="headerlink" title="覆盖重写"></a>覆盖重写</h3><p>如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略构造器与Getter Setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在IntelliJ IDEA中，可以点击<code>Code</code>菜单中的<code>Generate...</code>，也可以使用快捷键<code>alt+insert</code>，点击<code>toString()</code>选项。选择需要包含的成员变量并确定。如下图所示：</p><p><img src="img%5CtoString%E6%96%B9%E6%B3%95%E7%9A%84%E8%87%AA%E5%8A%A8%E9%87%8D%E5%86%99.bmp" alt="toString方法的自动重写"></p><blockquote><p>小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。</p></blockquote><h2 id="1-3-equals方法"><a href="#1-3-equals方法" class="headerlink" title="1.3 equals方法"></a>1.3 equals方法</h2><h3 id="方法摘要-1"><a href="#方法摘要-1" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul><li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li></ul><p>调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。</p><h3 id="默认地址比较"><a href="#默认地址比较" class="headerlink" title="默认地址比较"></a>默认地址比较</h3><p>如果没有覆盖重写equals方法，那么Object类中默认进行<code>==</code>运算符的对象地址比较，只要不是同一个对象，结果必然为false。</p><h3 id="对象内容比较"><a href="#对象内容比较" class="headerlink" title="对象内容比较"></a>对象内容比较</h3><p>如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果对象地址一样，则认为相同</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 如果参数为空，或者类型信息不一样，则认为不同</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 转换为当前类型</span></span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span></span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用<code>Code</code>菜单中的<code>Generate…</code>选项，也可以使用快捷键<code>alt+insert</code>，并选择<code>equals() and hashCode()</code>进行自动代码生成。如下图所示：</p><p><img src="img%5Cequals%E6%96%B9%E6%B3%951.png"></p><p><img src="img%5Cequals%E6%96%B9%E6%B3%952.png"></p><p><img src="img%5Cequals%E6%96%B9%E6%B3%953.png"></p><blockquote><p>tips：Object类当中的hashCode等其他方法，今后学习。</p></blockquote><h2 id="1-4-Objects类"><a href="#1-4-Objects类" class="headerlink" title="1.4 Objects类"></a>1.4 Objects类</h2><p>在刚才IDEA自动重写equals代码中，使用到了<code>java.util.Objects</code>类，那么这个类是什么呢？</p><p>在<strong>JDK7</strong>添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。</p><p>在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：</p><ul><li><code>public static boolean equals(Object a, Object b)</code>:判断两个对象是否相等。</li></ul><p>我们可以查看一下源码，学习一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第二章-日期时间类"><a href="#第二章-日期时间类" class="headerlink" title="第二章 日期时间类"></a>第二章 日期时间类</h1><h2 id="2-1-Date类"><a href="#2-1-Date类" class="headerlink" title="2.1 Date类"></a>2.1 Date类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code> java.util.Date</code>类 表示特定的瞬间，精确到毫秒。</p><p>继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。</p><ul><li><code>public Date()</code>：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。</li><li><code>public Date(long date)</code>：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。</li></ul><blockquote><p>tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。</p></blockquote><p>简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Date</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建日期对象，把当前的时间</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date()); <span class="comment">// Tue Jan 16 14:37:35 CST 2018</span></span><br><span class="line">        <span class="comment">// 创建日期对象，把当前的毫秒值转成日期对象</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date(<span class="number">0L</span>)); <span class="comment">// Thu Jan 01 08:00:00 CST 1970</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。</p></blockquote><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>Date类中的多数方法已经过时，常用的方法有：</p><ul><li><code>public long getTime()</code> 把日期对象转换成对应的时间毫秒值。</li></ul><h2 id="2-2-DateFormat类"><a href="#2-2-DateFormat类" class="headerlink" title="2.2 DateFormat类"></a>2.2 DateFormat类</h2><p><code>java.text.DateFormat</code> 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。</p><ul><li><strong>格式化</strong>：按照指定的格式，从Date对象转换为String对象。</li><li><strong>解析</strong>：按照指定的格式，从String对象转换为Date对象。</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>由于DateFormat为抽象类，不能直接使用，所以需要常用的子类<code>java.text.SimpleDateFormat</code>。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：</p><ul><li><code>public SimpleDateFormat(String pattern)</code>：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。</li></ul><p>参数pattern是一个字符串，代表日期时间的自定义格式。</p><h3 id="格式规则"><a href="#格式规则" class="headerlink" title="格式规则"></a>格式规则</h3><p>常用的格式规则为：</p><table><thead><tr><th>标识字母（区分大小写）</th><th>含义</th></tr></thead><tbody><tr><td>y</td><td>年</td></tr><tr><td>M</td><td>月</td></tr><tr><td>d</td><td>日</td></tr><tr><td>H</td><td>时</td></tr><tr><td>m</td><td>分</td></tr><tr><td>s</td><td>秒</td></tr></tbody></table><blockquote><p>备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。</p></blockquote><p>创建SimpleDateFormat对象的代码如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02SimpleDateFormat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对应的日期格式如：2018-01-16 15:06:38</span></span><br><span class="line">        DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>DateFormat类的常用方法有：</p><ul><li><code>public String format(Date date)</code>：将Date对象格式化为字符串。</li><li><code>public Date parse(String source)</code>：将字符串解析为Date对象。</li></ul><h4 id="format方法"><a href="#format方法" class="headerlink" title="format方法"></a>format方法</h4><p>使用format方法的代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 把Date对象转换成String</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03DateFormatMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">// 创建日期格式化对象,在获取格式化对象时可以指定风格</span></span><br><span class="line">        DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">        String str = df.format(date);</span><br><span class="line">        System.out.println(str); <span class="comment">// 2008年1月23日</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="parse方法"><a href="#parse方法" class="headerlink" title="parse方法"></a>parse方法</h4><p>使用parse方法的代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 把String转换成Date对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04DateFormatMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">        String str = <span class="string">&quot;2018年12月11日&quot;</span>;</span><br><span class="line">        Date date = df.parse(str);</span><br><span class="line">        System.out.println(date); <span class="comment">// Tue Dec 11 00:00:00 CST 2018</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-Calendar类"><a href="#2-3-Calendar类" class="headerlink" title="2.3 Calendar类"></a>2.3 Calendar类</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>日历我们都见过</p><p><img src="img%5C%E6%97%A5%E5%8E%86.jpg"></p><p><code>java.util.Calendar</code>是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。</p><h3 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h3><p>Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下：</p><p>Calendar静态方法</p><ul><li><code>public static Calendar getInstance()</code>：使用默认时区和语言环境获得一个日历</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06CalendarInit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><p>根据Calendar类的API文档，常用方法有：</p><ul><li><code>public int get(int field)</code>：返回给定日历字段的值。</li><li><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值。</li><li><code>public abstract void add(int field, int amount)</code>：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li><li><code>public Date getTime()</code>：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。</li></ul><p>Calendar类中提供很多成员常量，代表给定的日历字段：</p><table><thead><tr><th>字段值</th><th>含义</th></tr></thead><tbody><tr><td>YEAR</td><td>年</td></tr><tr><td>MONTH</td><td>月（从0开始，可以+1使用）</td></tr><tr><td>DAY_OF_MONTH</td><td>月中的天（几号）</td></tr><tr><td>HOUR</td><td>时（12小时制）</td></tr><tr><td>HOUR_OF_DAY</td><td>时（24小时制）</td></tr><tr><td>MINUTE</td><td>分</td></tr><tr><td>SECOND</td><td>秒</td></tr><tr><td>DAY_OF_WEEK</td><td>周中的天（周几，周日为1，可以-1使用）</td></tr></tbody></table><h4 id="get-set方法"><a href="#get-set方法" class="headerlink" title="get/set方法"></a>get/set方法</h4><p>get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Calendar对象</span></span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 设置年 </span></span><br><span class="line">        <span class="keyword">int</span> year = cal.get(Calendar.YEAR);</span><br><span class="line">        <span class="comment">// 设置月</span></span><br><span class="line">        <span class="keyword">int</span> month = cal.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 设置日</span></span><br><span class="line">        <span class="keyword">int</span> dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07CalendarMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        cal.set(Calendar.YEAR, <span class="number">2020</span>);</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2020年1月17日</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08CalendarMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2018年1月17日</span></span><br><span class="line">        <span class="comment">// 使用add方法</span></span><br><span class="line">        cal.add(Calendar.DAY_OF_MONTH, <span class="number">2</span>); <span class="comment">// 加2天</span></span><br><span class="line">        cal.add(Calendar.YEAR, -<span class="number">3</span>); <span class="comment">// 减3年</span></span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2015年1月18日; </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getTime方法"><a href="#getTime方法" class="headerlink" title="getTime方法"></a>getTime方法</h4><p>Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo09CalendarMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        Date date = cal.getTime();</span><br><span class="line">        System.out.println(date); <span class="comment">// Tue Jan 16 16:03:09 CST 2018</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小贴士：</p><p>​     西方星期的开始为周日，中国为周一。</p><p>​     在Calendar类中，月份的表示是以0-11代表1-12月。</p><p>​     日期是有大小关系的，时间靠后，时间越大。</p></blockquote><h1 id="第三章-System类"><a href="#第三章-System类" class="headerlink" title="第三章 System类"></a>第三章 System类</h1><p><code>java.lang.System</code>类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：</p><ul><li><code>public static long currentTimeMillis()</code>：返回以毫秒为单位的当前时间。</li><li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li></ul><h2 id="3-1-currentTimeMillis方法"><a href="#3-1-currentTimeMillis方法" class="headerlink" title="3.1 currentTimeMillis方法"></a>3.1 currentTimeMillis方法</h2><p>实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//获取当前时间毫秒值</span></span><br><span class="line">        System.out.println(System.currentTimeMillis()); <span class="comment">// 1516090531144</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>验证for循环打印数字1-9999所需要使用的时间（毫秒）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;共耗时毫秒：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-arraycopy方法"><a href="#3-2-arraycopy方法" class="headerlink" title="3.2 arraycopy方法"></a>3.2 arraycopy方法</h2><ul><li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li></ul><p>数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：</p><table><thead><tr><th>参数序号</th><th>参数名称</th><th>参数类型</th><th>参数含义</th></tr></thead><tbody><tr><td>1</td><td>src</td><td>Object</td><td>源数组</td></tr><tr><td>2</td><td>srcPos</td><td>int</td><td>源数组索引起始位置</td></tr><tr><td>3</td><td>dest</td><td>Object</td><td>目标数组</td></tr><tr><td>4</td><td>destPos</td><td>int</td><td>目标数组索引起始位置</td></tr><tr><td>5</td><td>length</td><td>int</td><td>复制元素个数</td></tr></tbody></table><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo11SystemArrayCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] src = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dest = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        System.arraycopy( src, <span class="number">0</span>, dest, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">/*代码运行后：两个数组中的元素发生了变化</span></span><br><span class="line"><span class="comment">         src数组元素[1,2,3,4,5]</span></span><br><span class="line"><span class="comment">         dest数组元素[1,2,3,9,10]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第四章-StringBuilder类"><a href="#第四章-StringBuilder类" class="headerlink" title="第四章 StringBuilder类"></a>第四章 StringBuilder类</h1><h2 id="4-1-字符串拼接问题"><a href="#4-1-字符串拼接问题" class="headerlink" title="4.1 字符串拼接问题"></a>4.1 字符串拼接问题</h2><p>由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        s += <span class="string">&quot;World&quot;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。</p><p>根据这句话分析我们的代码，其实总共产生了三个字符串，即<code>&quot;Hello&quot;</code>、<code>&quot;World&quot;</code>和<code>&quot;HelloWorld&quot;</code>。引用变量s首先指向<code>Hello</code>对象，最终指向拼接出来的新字符串对象，即<code>HelloWord</code> 。</p><p><img src="img%5CString%E6%8B%BC%E6%8E%A5%E9%97%AE%E9%A2%98.bmp"></p><p>由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用<code>java.lang.StringBuilder</code>类。</p><h2 id="4-2-StringBuilder概述"><a href="#4-2-StringBuilder概述" class="headerlink" title="4.2 StringBuilder概述"></a>4.2 StringBuilder概述</h2><p>查阅<code>java.lang.StringBuilder</code>的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p><p>原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p><p>它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充)</p><p><img src="img%5C06-StringBuilder%E7%9A%84%E5%8E%9F%E7%90%86.png" alt="06-StringBuilder的原理"></p><h2 id="4-3-构造方法"><a href="#4-3-构造方法" class="headerlink" title="4.3 构造方法"></a>4.3 构造方法</h2><p>根据StringBuilder的API文档，常用构造方法有2个：</p><ul><li><code>public StringBuilder()</code>：构造一个空的StringBuilder容器。</li><li><code>public StringBuilder(String str)</code>：构造一个StringBuilder容器，并将字符串添加进去。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        System.out.println(sb1); <span class="comment">// (空白)</span></span><br><span class="line">        <span class="comment">// 使用带参构造</span></span><br><span class="line">        StringBuilder sb2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        System.out.println(sb2); <span class="comment">// itcast</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-常用方法"><a href="#4-4-常用方法" class="headerlink" title="4.4 常用方法"></a>4.4 常用方法</h2><p>StringBuilder常用的方法有2个：</p><ul><li><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身。</li><li><code>public String toString()</code>：将当前StringBuilder对象转换为String对象。</li></ul><h3 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h3><p>append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02StringBuilder</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">//public StringBuilder append(任意类型)</span></span><br><span class="line">StringBuilder builder2 = builder.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//对比一下</span></span><br><span class="line">System.out.println(<span class="string">&quot;builder:&quot;</span>+builder);</span><br><span class="line">System.out.println(<span class="string">&quot;builder2:&quot;</span>+builder2);</span><br><span class="line">System.out.println(builder == builder2); <span class="comment">//true</span></span><br><span class="line">    <span class="comment">// 可以添加 任何类型</span></span><br><span class="line">builder.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">builder.append(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">builder.append(<span class="keyword">true</span>);</span><br><span class="line">builder.append(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。</span></span><br><span class="line">        <span class="comment">// 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下</span></span><br><span class="line"><span class="comment">//链式编程</span></span><br><span class="line">builder.append(<span class="string">&quot;hello&quot;</span>).append(<span class="string">&quot;world&quot;</span>).append(<span class="keyword">true</span>).append(<span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;builder:&quot;</span>+builder);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>备注：StringBuilder已经覆盖重写了Object当中的toString方法。</p></blockquote><h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo16StringBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 链式创建</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Hello&quot;</span>).append(<span class="string">&quot;World&quot;</span>).append(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        String str = sb.toString();</span><br><span class="line">        System.out.println(str); <span class="comment">// HelloWorldJava</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第五章-包装类"><a href="#第五章-包装类" class="headerlink" title="第五章 包装类"></a>第五章 包装类</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p><table><thead><tr><th>基本类型</th><th>对应的包装类（位于java.lang包中）</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td><strong>Integer</strong></td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td><strong>Character</strong></td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h2 id="5-2-装箱与拆箱"><a href="#5-2-装箱与拆箱" class="headerlink" title="5.2 装箱与拆箱"></a>5.2 装箱与拆箱</h2><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p><ul><li><p><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</p></li><li><p><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</p></li></ul><p>用Integer与 int为例：（看懂代码即可）</p><p>基本数值—-&gt;包装对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">4</span>);<span class="comment">//使用构造函数函数</span></span><br><span class="line">Integer iii = Integer.valueOf(<span class="number">4</span>);<span class="comment">//使用包装类中的valueOf方法</span></span><br></pre></td></tr></table></figure><p>包装对象—-&gt;基本数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = i.intValue();</span><br></pre></td></tr></table></figure><h2 id="5-3自动装箱与自动拆箱"><a href="#5-3自动装箱与自动拆箱" class="headerlink" title="5.3自动装箱与自动拆箱"></a>5.3自动装箱与自动拆箱</h2><p>由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">4</span>;<span class="comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span></span><br><span class="line">i = i + <span class="number">5</span>;<span class="comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span></span><br><span class="line"><span class="comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span></span><br></pre></td></tr></table></figure><h2 id="5-3-基本类型与字符串之间的转换"><a href="#5-3-基本类型与字符串之间的转换" class="headerlink" title="5.3 基本类型与字符串之间的转换"></a>5.3 基本类型与字符串之间的转换</h2><h3 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h3><p>   基本类型转换String总共有三种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">基本类型与字符串类型之间的相互转换</span><br><span class="line">基本类型-）字符串（String）</span><br><span class="line">1.基本类型的值+&quot; &quot;  最简单的方法 如：34+&quot;&quot;(工作中常用)</span><br><span class="line">2.包装类的静态方法tostring(参数),不是object类的tostring ()  重载</span><br><span class="line">static string tostring（int i）返回一个表示指定整数的 String对象。</span><br><span class="line">3.String类的静态方法valueof(参数)</span><br><span class="line">static string valueOf（int i）返回int 参数的字符串表示形式。</span><br></pre></td></tr></table></figure><p>String转换成对应的基本类型 </p><p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p><ul><li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li><li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li><li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li><li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li><li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li><li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li><li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</li></ul><p>代码使用（仅以Integer类的静态方法parseXxx为例）如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo18WrapperParse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识接口</title>
      <link href="2020/01/10/%E5%88%9D%E8%AF%86%E6%8E%A5%E5%8F%A3/"/>
      <url>2020/01/10/%E5%88%9D%E8%AF%86%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h2><p>接口(interface)是多个类的公共规范<br>接口是一种引用数据类型，最重要的内容就是其中的抽象方法。</p><p>定义一个接口格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名称</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口内容</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>tips</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一般.java--&gt;.class文件转换格式</span><br><span class="line"></span><br><span class="line">编译生成的字节码文件仍然是：.java--&gt;.class</span><br><span class="line"></span><br><span class="line">如果是java9，那么接口可以包含的内容：</span><br><span class="line"></span><br><span class="line">常量、抽象方法、默认方法、静态方法、私有方法</span><br></pre></td></tr></table></figure><h2 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h2><h4 id="抽象方法的使用"><a href="#抽象方法的使用" class="headerlink" title="抽象方法的使用"></a>抽象方法的使用</h4><p>抽象方法的使用，首先需要定义三个类或接口：</p><p>1.接口interface</p><p>2.实现类(接口的子类) implements</p><p>3.main方法类(又称测试类)</p><p>接口当中的抽象方法，修饰符必须是两个固定的关键字：<strong>public abstract</strong>，没有方法体{}</p><p>两个关键字修饰符，可以选择性省略。</p><p>比如下列代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> interface <span class="title">myinterface</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个抽象方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个抽象方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个抽象方法</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个抽象方法</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口使用"><a href="#接口使用" class="headerlink" title="接口使用"></a>接口使用</h4><p>类比抽象方法的用法，比较两者之间的区别</p><p>1.接口不能直接使用，必须用一个“实现类”来”实现”该接口。</p><p>实现类定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 实现类名称 <span class="keyword">implements</span> 接口名称</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.接口的实现类必须覆盖重写(实现)接口中的所有抽象方法</p><p>实现：去掉abstract关键字，加上方法体大括号</p><p>3.创建实现类的对象，进行使用 </p><p> 不能直接new接口对象使用，需要实现类的对象使用。</p><p>如果实现类并没有覆盖重写(实现)接口中所有的抽象方法，那么这个实现类就必须是抽象类。</p><h5 id="接口的默认方法使用-关键字：default"><a href="#接口的默认方法使用-关键字：default" class="headerlink" title="接口的默认方法使用(关键字：default)"></a>接口的默认方法使用(关键字：<strong>default</strong>)</h5><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">default</span> 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>tips</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">接口当中的默认方法，可以解决接口升级问题。在接口中添加默认方法，</span><br><span class="line"></span><br><span class="line">1.接口的默认方法，可以通过接口实现类对象，直接调用</span><br><span class="line"></span><br><span class="line">2.接口的默认方法，也可以被接口实现类进行覆盖重写</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="接口的静态方法使用-关键字：static"><a href="#接口的静态方法使用-关键字：static" class="headerlink" title="接口的静态方法使用(关键字：static)"></a>接口的静态方法使用(关键字：static)</h5><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>tips</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.不能通过接口实现类的对象来调用接口当中的静态方法。(静态与对象无关，跟类有关，所以不能用对象来调用静态方法)</span><br><span class="line"></span><br><span class="line">2.通过接口名称，直接调用其中的静态方法</span><br></pre></td></tr></table></figure><h5 id="接口私有方法的使用-关键字：private"><a href="#接口私有方法的使用-关键字：private" class="headerlink" title="接口私有方法的使用(关键字：private)"></a>接口私有方法的使用(关键字：private)</h5><p>只能接口自己使用，实现类不能调用</p><p>1.普通私有方法，解决多个默认方法之间重复代码问题</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.静态私有方法：解决多个静态方法之间重复代码的问题</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h5 id="接口中常量的定义和使用"><a href="#接口中常量的定义和使用" class="headerlink" title="接口中常量的定义和使用"></a>接口中常量的定义和使用</h5><p>接口的 “成员变量”, <code>public static final</code>进行修饰(可省略)</p><p>从效果来看，其实就是接口的“常量”</p><p>格式:<code>public static final 数据类型 常量，名称 = 数据值;</code></p><p><strong>一旦使用final关键字进行修饰，说明不可变。</strong></p><p>注意：</p><p>1.接口当中的常量，必须‌进行赋值，不能不赋值。</p><p>2.接口中常量的名称用大写，下划线进行分割。</p><h4 id="接口的多实现"><a href="#接口的多实现" class="headerlink" title="接口的多实现"></a>接口的多实现</h4><p>1.接口是没有静态代码块或者构造方法的</p><p>2.一个类的直接父类是唯一的，但是一个类可以同时实现多个接口</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myinterfaceImpl</span> <span class="keyword">implements</span> <span class="title">MyinterfaceA</span>,<span class="title">MyinterfaceB</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//覆盖重写所有的抽象方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.如果实现类所实现的多个接口中，存在重复的抽象方法，那么只需要覆盖重写一次即可。</p><p>4.如果实现类没有覆盖重写所有的接口当中的所有抽象方法，那么实现类就必须是一个抽象类</p><p>5.如果实现类所实现的多个接口中，有重名的默认方法，实现类一定要对冲突的默认方法进行覆盖重写。</p><p>6.优先级问题 ：当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执 行父类的成员方法。</p><h4 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h4><p>1.类与类之间是单继承的</p><p>2.类与接口之间的是多实现的，一个类可以实现多个接口</p><p>3.接口之间是多继承的</p><p>注意：</p><p>1.多个父接口当中的抽象方法如果重复，没关系</p><p>2.多个父接口当中的默认方法有重复，那么子接口必须进行默认方法的覆盖重写【而且带着default关键字】</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符总结</title>
      <link href="2020/01/10/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>2020/01/10/%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="一、基础运算符（-）"><a href="#一、基础运算符（-）" class="headerlink" title="一、基础运算符（+-*/%）"></a>一、基础运算符（+-*/%）</h3><p>注意：一旦运算中有不同类型的数据，那么结果是数据类型范围大的那种<br>四则运算中的加号：<br>1.对数值来说就是加法</p><p>2.对字符char类型来说，在计算之前，char会提升为int再计算，对照关系表ASCII、unicode</p><p>3.对于字符串Sring（首字母大写，并不是关键字）来说，加号代表字符串连接操作。<br>即任何数据类型和字符串进行连接的时候，结果都会变成字符串</p><p><code>string + int--&gt;string</code><br>优先级：<br><code>string + int+ int</code>&gt;<code>string + int</code>&gt;<code>string</code></p><h3 id="二、自增自减运算符"><a href="#二、自增自减运算符" class="headerlink" title="二、自增自减运算符"></a>二、自增自减运算符</h3><p>自增运算符：++<br>自减运算符：–<br>让一个变量涨一个数字1，或者减一个数字1</p><p>写在变量名称之前，或者写在变量名称之后，如++num，num++<br>1.单独使用的时候，前后++没区别<br>2.混合使用有区别<br>    a.如果是前++，那么变量立刻+1，拿着结果进行使用（先加后用）<br>    b.若果是后++ ，先使用变量本来的数值，再让变量+1（先用后加）<br>tips: 只有变量才可以用自增自减运算</p><h3 id="三、赋值运算符"><a href="#三、赋值运算符" class="headerlink" title="三、赋值运算符"></a>三、赋值运算符</h3><p>分为基本赋值运算符、复合赋值运算符<br><code>+= a+=1</code> 相当于  <code>a = a + 1</code></p><p><code>-=  b-=2 </code>相当于 <code> b = b - 2</code></p><p><code>= c*=3</code>  相当于  <code>c = c * 3</code></p><p><code>/= d/= 4</code> 相当于 <code> d = d / 4</code></p><p><code>%= e%=5</code> 相当于  <code>e = e % 5</code></p><p>1.只有变量才能使用赋值运算符号，常量不能赋值<br>2.复合赋值运算符隐含了一个强制类型转换</p><h3 id="四、比较运算符"><a href="#四、比较运算符" class="headerlink" title="四、比较运算符"></a>四、比较运算符</h3><p><code>==，&lt;,&gt;,&lt;=,&gt;=,!=</code></p><p>1.比较运算符的结果一定是一个Boolean值，即true或者false</p><p>2.进行多次判断，不能连着写</p><p>1&lt;x&lt;3（不允许）</p><h3 id="五、逻辑运算符"><a href="#五、逻辑运算符" class="headerlink" title="五、逻辑运算符"></a>五、逻辑运算符</h3><p>与（并且）&amp;&amp; 两者为真才为真，一假就为假（true）</p><p>或（或者） | |  一真则为真，全假才是假（false）</p><p>非（取反） ！ 本来是true，变成false</p><p>与“&amp;&amp;，”或“”| |，具有短路效果：如果根据左边已经可以判断出最终结果，那么右边的代码不再执行，从而节省一定的性能 （false&amp;&amp;…左边已经能够判断出来true，所以后面不用计算）</p><p>注意：1.逻辑运算符只能为Boolean值</p><p>2.与、或需要左右各自一个Boolean值，但是非只要有唯一一个Boolean值即可</p><p>3.与、或两种运算符，如果有多个条件，可以连续写</p><p>两个：条件A&amp;&amp;条件B</p><p>多个：条件A&amp;&amp;条件B&amp;&amp;条件C</p><p>tip： 对于1&lt;x&lt;3,可以拆分成两个部分与运算符连接起来</p><p>int x=2；</p><p>1&lt;x&amp;&amp;x&lt;3；</p><h3 id="六、多元运算符"><a href="#六、多元运算符" class="headerlink" title="六、多元运算符"></a>六、多元运算符</h3><p>一元运算符：！，++，–等</p><p>三元运算符：需要三个数据才可以进行操作的字符</p><p>数据类型 变量名称 = 条件判断 ？ 表达式A：表达式B</p><p>流程：</p><p>首先判断条件是否成立：</p><p>如果成立为true，那么将表达式A的值赋给左侧的变量;</p><p>如果不成立则为false，将表达式B的值赋给左侧的变量；</p><p>二者选其一。</p><p>注意：</p><p>1.必须同时保证表达式A和B都符合左侧数据类型的要求</p><p>2.三元运算符的结果必须被使用</p><h3 id="七、位运算符："><a href="#七、位运算符：" class="headerlink" title="七、位运算符："></a>七、位运算符：</h3><p>补码的负数表示：例如-1:11111111 11111111 这里首位为1表示负数，直接算后面八位，即11111111。第一位为负数且表示为-128，后面剩下的七位则相加并且是正数，这样-128+127即为-1.</p><p>位运算符有七个，并且并不是运算数值，而是在二进制上进行运算。即&amp;，|，~，^,&lt;&lt;,&gt;&gt;,&gt;&gt;&gt;</p><p>位与运算符&amp;：相同数保留，其余为0</p><p>位或运算符|：有1就保留</p><p>位异或运算符^：有相同就为0，不相同为1</p><p>位取反运算符~：取反，即0变成1,1变成0</p><p>左移、右移运算符：</p><p><code>&lt;&lt;</code> 除以2</p><p><code>&gt;&gt;</code> 乘以2</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
